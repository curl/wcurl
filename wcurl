#!/bin/sh

# wcurl - a simple wrapper around curl to easily download files.
#
# Requires curl >= 7.46.0 (2015)
#
# Copyright (C) Samuel Henrique <samueloph@debian.org>, Sergio Durigan
# Junior <sergiodj@debian.org> and many contributors, see the AUTHORS
# file.
#
# Permission to use, copy, modify, and distribute this software for any purpose
# with or without fee is hereby granted, provided that the above copyright
# notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS. IN
# NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
# DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
# OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
# OR OTHER DEALINGS IN THE SOFTWARE.
#
# Except as contained in this notice, the name of a copyright holder shall not be
# used in advertising or otherwise to promote the sale, use or other dealings in
# this Software without prior written authorization of the copyright holder.
#
# SPDX-License-Identifier: curl

# Stop on errors and on usage of unset variables.
set -eu

VERSION="2025.11.09"

PROGRAM_NAME="$(basename "$0")"
readonly PROGRAM_NAME

# Display the version.
print_version()
{
    cat << _EOF_
${VERSION}
_EOF_
}

# Display the program usage.
usage()
{
    cat << _EOF_
${PROGRAM_NAME} -- a simple wrapper around curl to easily download files.

Usage: ${PROGRAM_NAME} <URL>...
       ${PROGRAM_NAME} [--curl-options <CURL_OPTIONS>]... [--no-decode-filename] [-o|-O|--output <PATH>] [--dry-run] [--] <URL>...
       ${PROGRAM_NAME} [--curl-options=<CURL_OPTIONS>]... [--no-decode-filename] [--output=<PATH>] [--dry-run] [--] <URL>...
       ${PROGRAM_NAME} [--save-call=<NAME>:<CURL_OPTIONS>]... [--list-save] [--rm-save=<NAME>]
       ${PROGRAM_NAME} [-r|--run-save=<NAME>] <URL>...
       ${PROGRAM_NAME} -h|--help
       ${PROGRAM_NAME} -V|--version

Options:

  --curl-options <CURL_OPTIONS>: Specify extra options to be passed when invoking curl. May be
                                 specified more than once.

  -o, -O, --output <PATH>: Use the provided output path instead of getting it from the URL. If
                           multiple URLs are provided, resulting files share the same name with a
                           number appended to the end (curl >= 7.83.0). If this option is provided
                           multiple times, only the last value is considered.

  --no-decode-filename: Do not percent-decode the output filename, even if the percent-encoding in
                        the URL was done by wcurl, e.g.: The URL contained whitespace.

  --dry-run: Do not actually execute curl, just print what would be invoked.

  --save-call <NAME>:<CURL_OPTIONS>: Save a curl call to $HOME/.wcurlrc without having to remember
                                     option combinations, using a property value set; where the value
                                     is the set of options to be reused, and the property is the name
                                     to invoke the saved option combo. Name must contain only alphanumeric
                                     characters, dashes, and underscores. Supports parameter expansion
                                     using !1, !2, !3, etc. as placeholders that will be replaced with
                                     actual values when invoked with -r or --run-save. When using
                                     parameter expansion markers, enclose the curl options in single
                                     quotes to prevent shell interpretation.

  -r, --run-save <NAME>: Run a saved curl call from $HOME/.wcurlrc. For saved calls without
                         parameter expansion, the saved options are applied to the URLs provided.
                         For saved calls with parameter expansion markers (!1, !2, !3, etc.), you
                         must provide the exact number of parameters required by the highest marker
                         number. When using parameter expansion, only one --run-save call can be used
                         per command, and the command executes curl directly with the expanded options.
                         Parameters are provided as separate arguments following the --run-save option.

  --list-save: Output the name and the option combination for each name from $HOME/.wcurlrc
               that have been saved for later reuse.

  --rm-save <NAME>: Remove a saved curl call from $HOME/.wcurlrc.

  -V, --version: Print version information.

  -h, --help: Print this usage message.

  <CURL_OPTIONS>: Any option supported by curl can be set here. This is not used by wcurl; it is
                 instead forwarded to the curl invocation.

  <URL>: URL to be downloaded. Anything that is not a parameter is considered
         an URL. Whitespace is percent-encoded and the URL is passed to curl, which
         then performs the parsing. May be specified more than once.
_EOF_
}

# Display an error message and bail out.
error()
{
    printf "%s\n" "$*" >&2
    exit 1
}

# Extra curl options provided by the user.
# This is set per-URL for every URL provided.
# Some options are global, but we are erroring on the side of needlessly setting
# them multiple times instead of causing issues with parameters that needs to
# be set per-URL.
CURL_OPTIONS=""

# The URLs to be downloaded.
URLS=""

# Variable used to be set to the percent-decoded filename parsed from the URL, unless
# --output or --no-decode-filename are used.
OUTPUT_PATH=""
HAS_USER_SET_OUTPUT="false"

# The parameters that are passed per-URL to curl.
readonly PER_URL_PARAMETERS="\
    --fail \
    --globoff \
    --location \
    --proto-default https \
    --remote-time \
    --retry 5 "

# Valid percent-encode codes that are considered unsafe to be decoded.
# This is a list of space-separated percent-encoded uppercase
# characters.
# 2F = /
# 5C = \
readonly UNSAFE_PERCENT_ENCODE="%2F %5C"

# Whether to invoke curl or not.
DRY_RUN="false"

# Save-call name and options for --save-call
SAVE_CALL_NAME=""
SAVE_CALL_OPTIONS=""
HAS_SAVE_CALLS="false"

# Save a curl call to .wcurlrc
save_call()
{
    if [ -z "${SAVE_CALL_NAME}" ]; then
        error "No save-call name provided."
    fi

    # Validate name: only allow alphanumeric, dash, underscore
    case "${SAVE_CALL_NAME}" in
        *[!a-zA-Z0-9_-]*)
            error "Invalid characters in save-call name. Use only letters, numbers, dash, and underscore."
            ;;
    esac

    if [ -z "${SAVE_CALL_OPTIONS}" ]; then
        error "No options provided for save-call."
    fi

    wcurlrc="${HOME}/.wcurlrc"

    # Create .wcurlrc if it doesn't exist with secure permissions
    if [ ! -f "${wcurlrc}" ]; then
        touch "${wcurlrc}"
        chmod 600 "${wcurlrc}"
    else
        # Fix permissions on existing file if they're too permissive
        current_perms=$(stat -c '%a' "${wcurlrc}" 2>/dev/null || stat -f '%Lp' "${wcurlrc}" 2>/dev/null || echo "600")
        if [ "${current_perms}" != "600" ]; then
            chmod 600 "${wcurlrc}"
        fi
    fi

    # Escape the name for use in grep pattern (escape regex metacharacters)
    escaped_name=$(printf "%s" "${SAVE_CALL_NAME}" | sed 's/[.\[^$*]/\\&/g')

    # Check if name already exists and update it, otherwise append
    if grep -q "^${escaped_name}=" "${wcurlrc}" 2>/dev/null; then
        # Update existing entry using a secure temp file
        temp_file=$(mktemp "${wcurlrc}.XXXXXX") || error "Failed to create temp file"
        chmod 600 "${temp_file}"
        grep -v "^${escaped_name}=" "${wcurlrc}" > "${temp_file}" 2>/dev/null || true
        printf "%s=%s\n" "${SAVE_CALL_NAME}" "${SAVE_CALL_OPTIONS}" >> "${temp_file}"
        mv "${temp_file}" "${wcurlrc}"
    else
        # Append new entry
        printf "%s=%s\n" "${SAVE_CALL_NAME}" "${SAVE_CALL_OPTIONS}" >> "${wcurlrc}"
    fi

    printf "Saved call '%s' with options: %s\n" "${SAVE_CALL_NAME}" "${SAVE_CALL_OPTIONS}"
}

# Load saved call from .wcurlrc
get_saved_call()
{
    name="${1}"
    wcurlrc="${HOME}/.wcurlrc"

    if [ ! -f "${wcurlrc}" ]; then
        return 1
    fi

    # Look for the saved call
    saved_options=$(grep "^${name}=" "${wcurlrc}" 2>/dev/null | sed "s/^${name}=//")

    if [ -n "${saved_options}" ]; then
        printf "%s" "${saved_options}"
        return 0
    fi

    return 1
}

# List all saved calls from .wcurlrc
list_saved_calls()
{
    wcurlrc="${HOME}/.wcurlrc"

    if [ ! -f "${wcurlrc}" ]; then
        printf "No saved calls found. File does not exist: %s\n" "${wcurlrc}"
        exit 0
    fi

    if [ ! -s "${wcurlrc}" ]; then
        printf "No saved calls found in: %s\n" "${wcurlrc}"
        exit 0
    fi

    printf "Saved calls in %s:\n\n" "${wcurlrc}"

    # Read and display each saved call
    while IFS= read -r line; do
        # Skip empty lines and comments
        case "${line}" in
            ''|'#'*) continue ;;
        esac

        # Validate that the line contains an equals sign and has a valid name
        case "${line}" in
            *=*)
                # Extract name and check if it's valid (starts with alphanumeric)
                name=$(printf "%s" "${line}" | cut -d= -f1)
                case "${name}" in
                    [a-zA-Z0-9]*)
                        # Valid entry
                        options=$(printf "%s" "${line}" | cut -d= -f2-)
                        printf "  %s:\n    %s\n\n" "${name}" "${options}"
                        ;;
                    *)
                        # Invalid name (starts with space, quote, etc.), skip
                        continue
                        ;;
                esac
                ;;
            *)
                # No equals sign, skip
                continue
                ;;
        esac
    done < "${wcurlrc}"

    exit 0
}

# Remove a saved call from .wcurlrc
remove_call()
{
    if [ -z "${1}" ]; then
        error "No call name provided to remove."
    fi

    name="${1}"
    wcurlrc="${HOME}/.wcurlrc"

    if [ ! -f "${wcurlrc}" ]; then
        error "No saved calls found. File does not exist: ${wcurlrc}"
    fi

    # Escape the name for use in grep pattern
    escaped_name=$(printf "%s" "${name}" | sed 's/[.\[^$*]/\\&/g')

    # Check if the call exists
    if ! grep -q "^${escaped_name}=" "${wcurlrc}" 2>/dev/null; then
        error "Saved call '${name}' not found in ${wcurlrc}"
    fi

    # Remove the entry using a secure temp file
    temp_file=$(mktemp "${wcurlrc}.XXXXXX") || error "Failed to create temp file"
    chmod 600 "${temp_file}"
    grep -v "^${escaped_name}=" "${wcurlrc}" > "${temp_file}" 2>/dev/null || true
    mv "${temp_file}" "${wcurlrc}"

    printf "Removed saved call: %s\n" "${name}"
    exit 0
}

# Sanitize parameters.
sanitize()
{
    # If we only had save-calls and no URLs, exit successfully
    if [ "${HAS_SAVE_CALLS}" = "true" ] && [ -z "${URLS}" ]; then
        printf "Saved to: %s\n" "${HOME}/.wcurlrc"
        exit 0
    fi

    if [ -z "${URLS}" ]; then
        error "You must provide at least one URL to download."
    fi

    readonly CURL_OPTIONS URLS DRY_RUN HAS_USER_SET_OUTPUT
}

# Indicate via exit code whether the string given in the first parameter
# consists solely of characters from the string given in the second parameter.
# In other words, it returns 0 if the first parameter only contains characters
# from the second parameter, e.g.: Are $1 characters a subset of $2 characters?
is_subset_of()
{
    case "${1}" in
        *[!${2}]* | '') return 1 ;;
    esac
}

# Indicate via exit code whether the HTML code given in the first
# parameter is safe to be decoded.
is_safe_percent_encode()
{
    upper_str=$(printf "%s" "${1}" | tr "[:lower:]" "[:upper:]")
    for unsafe in ${UNSAFE_PERCENT_ENCODE}; do
        if [ "${unsafe}" = "${upper_str}" ]; then
            return 1
        fi
    done

    return 0
}

# Print the given string percent-decoded.
percent_decode()
{
    # Encodings of control characters (00-1F) are passed through without decoding.
    # Iterate on the input character-by-character, decoding it.
    printf "%s\n" "${1}" | fold -w1 | while IFS= read -r decode_out; do
        # If character is a "%", read the next character as decode_hex1.
        if [ "${decode_out}" = % ] && IFS= read -r decode_hex1; then
            decode_out="${decode_out}${decode_hex1}"
            # If there is one more character, read it as decode_hex2.
            if IFS= read -r decode_hex2; then
                decode_out="${decode_out}${decode_hex2}"
                # Skip decoding if this is a control character (00-1F).
                # Skip decoding if DECODE_FILENAME is not "true".
                if [ "${DECODE_FILENAME}" = "true" ] \
                    && is_subset_of "${decode_hex1}" "23456789abcdefABCDEF" \
                    && is_subset_of "${decode_hex2}" "0123456789abcdefABCDEF" \
                    && is_safe_percent_encode "${decode_out}"; then
                    # Use printf to decode it into octal and then decode it to the final format.
                    decode_out="$(printf "%b" "\\$(printf %o "0x${decode_hex1}${decode_hex2}")")"
                fi
            fi
        fi
        printf %s "${decode_out}"
    done
}

# Print the percent-decoded filename portion of the given URL.
get_url_filename()
{
    # Remove protocol and query string if present.
    hostname_and_path="$(printf %s "${1}" | sed -e 's,^[^/]*//,,' -e 's,?.*$,,')"
    # If what remains contains a slash, there is a path; return it percent-decoded.
    case "${hostname_and_path}" in
        # sed to remove everything preceding the last '/', e.g.: "example/something" becomes "something"
        */*) percent_decode "$(printf %s "${hostname_and_path}" | sed -e 's,^.*/,,')" ;;
    esac
    # No slash means there was just a hostname and no path; return empty string.
}

# Execute curl with the list of URLs provided by the user.
exec_curl()
{
    CMD="curl "

    # Store version to check if it supports --no-clobber, --parallel and --parallel-max-host.
    curl_version=$($CMD --version | cut -f2 -d' ' | head -n1)
    curl_version_major=$(echo "$curl_version" | cut -f1 -d.)
    curl_version_minor=$(echo "$curl_version" | cut -f2 -d.)

    CURL_NO_CLOBBER=""
    CURL_PARALLEL=""

    if [ "${curl_version_major}" -ge 8 ]; then
        CURL_NO_CLOBBER="--no-clobber"
        CURL_PARALLEL="--parallel --parallel-max-host 5"

        # --parallel-max-host is only supported since 8.16.0.
        if [ "${curl_version_major}" -eq 8 ] && [ "${curl_version_minor}" -lt 16 ]; then
            CURL_PARALLEL="--parallel"
        fi
    elif [ "${curl_version_major}" -eq 7 ]; then
        # --no-clobber is only supported since 7.83.0.
        if [ "${curl_version_minor}" -ge 83 ]; then
            CURL_NO_CLOBBER="--no-clobber"
        fi
        # --parallel is only supported since 7.66.0.
        if [ "${curl_version_minor}" -ge 66 ]; then
            CURL_PARALLEL="--parallel"
        fi
    fi

    # Detecting whether we need --parallel. It is easier to rely on
    # the shell's argument parsing.
    # shellcheck disable=SC2086
    set -- $URLS

    # If there are less than two URLs, do not set the parallel flag.
    if [ "$#" -lt 2 ]; then
        CURL_PARALLEL=""
    fi

    # Start assembling the command.
    #
    # We use 'set --' here (again) because (a) we do not have arrays on
    # POSIX shell, and (b) we need better control over the way we
    # split arguments.
    #
    # shellcheck disable=SC2086
    set -- ${CMD} ${CURL_PARALLEL}

    NEXT_PARAMETER=""
    for url in ${URLS}; do
        # If the user did not provide an output path, define one.
        if [ "${HAS_USER_SET_OUTPUT}" = "false" ]; then
            OUTPUT_PATH="$(get_url_filename "${url}")"
            # If we could not get a path from the URL, use the default: index.html.
            [ -z "${OUTPUT_PATH}" ] && OUTPUT_PATH=index.html
        fi
        # shellcheck disable=SC2086
        set -- "$@" ${NEXT_PARAMETER} ${PER_URL_PARAMETERS} ${CURL_NO_CLOBBER} --output "${OUTPUT_PATH}" ${CURL_OPTIONS} "${url}"
        NEXT_PARAMETER="--next"
    done

    if [ "${DRY_RUN}" = "false" ]; then
        exec "$@"
    else
        printf "%s\n" "$@"
    fi
}

# Default to decoding the output filename
DECODE_FILENAME="true"

# Preprocess arguments to expand -r/--run-save options to --curl-options (non-parameter expansion case only)
preprocess_run_options()
{
    result=""

    while [ "$#" -gt 0 ]; do
        case "${1}" in
            -r=*|--run-save=*)
                run_value=$(printf "%s\n" "${1}" | sed 's/^\(-r\|--run-save\)=//')
                saved=$(get_saved_call "${run_value}" 2>/dev/null || true)

                if [ -n "${saved}" ]; then
                    result="${result} --curl-options='${saved}'"
                else
                    result="${result} --curl-options='${run_value}'"
                fi
                shift
                ;;

            *)
                result="${result} '${1}'"
                shift
                ;;
        esac
    done

    printf "%s" "${result}"
}

# Preprocess arguments if -r or --run-save is present
# First check if -r/--run-save uses parameter expansion and handle it directly
for arg in "$@"; do
    case "${arg}" in
        -r=*|--run-save=*)
            run_value=$(printf "%s\n" "${arg}" | sed 's/^\(-r\|--run-save\)=//')
            saved=$(get_saved_call "${run_value}" 2>/dev/null || true)

            if [ -n "${saved}" ] && printf "%s" "${saved}" | grep -q '!'; then
                # This uses parameter expansion - check for --dry-run first
                has_dry_run="false"
                for check_arg in "$@"; do
                    case "${check_arg}" in
                        --dry-run)
                            has_dry_run="true"
                            break
                            ;;
                    esac
                done

                # Remove arguments up to and including --run-save=name
                while [ "$#" -gt 0 ]; do
                    current_arg="${1}"
                    shift
                    case "${current_arg}" in
                        -r=*|--run-save=*)
                            # Found and removed the --run-save arg, now collect parameters
                            break
                            ;;
                    esac
                done

                # Find the highest parameter number
                max_param=0
                i=1
                while [ "${i}" -le 99 ]; do
                    if printf "%s" "${saved}" | grep -q "!${i}"; then
                        max_param="${i}"
                    fi
                    i=$((i + 1))
                done

                # Collect parameters (skip --dry-run if present, it was already removed above)
                param_count=0
                while [ "${param_count}" -lt "${max_param}" ] && [ "$#" -gt 0 ]; do
                    case "${1}" in
                        --*)
                            break
                            ;;
                        *)
                            param_count=$((param_count + 1))
                            eval "param_${param_count}='${1}'"
                            shift
                            ;;
                    esac
                done

                # Validate
                if [ "${param_count}" -lt "${max_param}" ]; then
                    error "Not enough parameters for --run=${run_value}. Expected at least ${max_param} parameters, got ${param_count}."
                fi

                # Perform substitution - build curl command array safely
                # We need to parse the saved options and substitute parameters
                # Process in REVERSE order (largest numbers first) to avoid !1 matching !10, !11, etc.
                expanded_opts="${saved}"
                i="${max_param}"
                while [ "${i}" -ge 1 ]; do
                    # shellcheck disable=SC2154
                    eval "param_value=\${param_${i}}"
                    # Use word boundary to match exact parameter number
                    # Match !N followed by non-digit or end of string
                    # First replace with unique marker
                    marker="__WCURL_PARAM_${i}__"
                    expanded_opts=$(printf "%s" "${expanded_opts}" | sed "s|!${i}\([^0-9]\)|${marker}\1|g; s|!${i}$|${marker}|g")
                    # Then replace marker with escaped value (escape single quotes for shell)
                    # shellcheck disable=SC2154
                    param_escaped=$(printf "%s" "${param_value}" | sed "s/'/'\\\\''/g")
                    expanded_opts=$(printf "%s" "${expanded_opts}" | sed "s|${marker}|'${param_escaped}'|g")
                    i=$((i - 1))
                done

                # Execute curl directly - use sh -c with proper quoting to avoid eval
                # If --dry-run was detected, just show the command instead
                if [ "${has_dry_run}" = "true" ]; then
                    printf "curl %s\n" "${expanded_opts}"
                    exit 0
                else
                    sh -c "curl ${expanded_opts}"
                    exit $?
                fi
            fi
            ;;
    esac
done

# If we get here, no parameter expansion was found - proceed with normal preprocessing
has_run_option="false"
for arg in "$@"; do
    case "${arg}" in
        -r=*|--run-save=*)
            has_run_option="true"
            break
            ;;
    esac
done

if [ "${has_run_option}" = "true" ]; then
    # Expand -r/--run-save options to --curl-options (non-parameter expansion case)
    expanded_args=$(preprocess_run_options "$@")
    # Reset positional parameters
    # shellcheck disable=SC2086
    eval set -- ${expanded_args}
fi

# Use "${1-}" in order to avoid errors because of 'set -u'.
while [ -n "${1-}" ]; do
    case "${1}" in
        --curl-options=*)
            opt=$(printf "%s\n" "${1}" | sed 's/^--curl-options=//')
            CURL_OPTIONS="${CURL_OPTIONS} ${opt}"
            ;;

        --curl-options)
            shift
            CURL_OPTIONS="${CURL_OPTIONS} ${1}"
            ;;

        --dry-run)
            DRY_RUN="true"
            ;;

        --output=*)
            opt=$(printf "%s\n" "${1}" | sed 's/^--output=//')
            HAS_USER_SET_OUTPUT="true"
            OUTPUT_PATH="${opt}"
            ;;

        -o | -O | --output)
            shift
            HAS_USER_SET_OUTPUT="true"
            OUTPUT_PATH="${1}"
            ;;

        -o* | -O*)
            opt=$(printf "%s\n" "${1}" | sed 's/^-[oO]//')
            HAS_USER_SET_OUTPUT="true"
            OUTPUT_PATH="${opt}"
            ;;

        --no-decode-filename)
            DECODE_FILENAME="false"
            ;;

        --save-call=*)
            opt=$(printf "%s\n" "${1}" | sed 's/^--save-call=//')

            # Check if the format contains a colon
            case "${opt}" in
                *:*)
                    SAVE_CALL_NAME=$(printf "%s\n" "${opt}" | cut -d: -f1)
                    SAVE_CALL_OPTIONS=$(printf "%s\n" "${opt}" | cut -d: -f2-)

                    # Check if there are unquoted spaces in options (indicates missing quotes)
                    # This happens when shell splits the argument
                    if [ -z "${SAVE_CALL_OPTIONS}" ]; then
                        error "--save-call options cannot be empty. Use format: --save-call=NAME:\"CURL_OPTIONS\""
                    fi
                    ;;
                *)
                    error "--save-call requires a colon separator. Use format: --save-call=NAME:\"CURL_OPTIONS\""
                    ;;
            esac

            HAS_SAVE_CALLS="true"
            save_call
            # Reset for next potential save-call
            SAVE_CALL_NAME=""
            SAVE_CALL_OPTIONS=""
            ;;

        --save-call)
            error "--save-call requires a value in the format: --save-call=NAME:\"CURL_OPTIONS\""
            ;;

        --list-save)
            list_saved_calls
            ;;

        --rm-save=*)
            opt=$(printf "%s\n" "${1}" | sed 's/^--rm-save=//')
            remove_call "${opt}"
            ;;

        --rm-save)
            error "--rm-save requires a value. Use format: --rm-save=NAME"
            ;;

        # Catch unquoted save-call attempts that got split by the shell
        -R | -z | -L)
            # Check if the previous argument pattern suggests a malformed --save-call
            # This is a heuristic - if we see curl options appearing as separate arguments
            # early in parsing before any URLs, it might be a quote issue
            if [ -z "${URLS}" ] && [ "${HAS_SAVE_CALLS}" = "true" ]; then
                error "Detected unquoted curl options. When using --save-call with multiple options, quote them: --save-call=NAME:\"-R -z -L\""
            fi
            # Otherwise treat as unknown option
            error "Unknown option: '$1'."
            ;;

        -h | --help)
            usage
            exit 0
            ;;

        -V | --version)
            print_version
            exit 0
            ;;

        --)
            # This is the start of the list of URLs.
            shift
            for url in "$@"; do
                # Encode whitespace into %20, since wget supports those URLs.
                newurl=$(printf "%s\n" "${url}" | sed 's/ /%20/g')
                URLS="${URLS} ${newurl}"
            done
            break
            ;;

        -*)
            error "Unknown option: '$1'."
            ;;

        *)
            # This must be a URL.
            # Encode whitespace into %20, since wget supports those URLs.
            newurl=$(printf "%s\n" "${1}" | sed 's/ /%20/g')
            URLS="${URLS} ${newurl}"
            ;;
    esac
    shift
done

sanitize
exec_curl
